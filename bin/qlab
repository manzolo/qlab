#!/usr/bin/env bash
set -euo pipefail

# QLab - Modular CLI for QEMU/KVM educational labs
# https://github.com/manzolo/qlab

# Resolve the root directory of the project (follows symlinks)
QLAB_SOURCE="${BASH_SOURCE[0]}"
while [[ -L "$QLAB_SOURCE" ]]; do
    QLAB_SOURCE="$(readlink "$QLAB_SOURCE")"
done
QLAB_ROOT="$(cd "$(dirname "$QLAB_SOURCE")/.." && pwd)"
export QLAB_ROOT

# Source all library files
for lib_file in "$QLAB_ROOT"/lib/*.bash; do
    # shellcheck source=/dev/null
    [[ -f "$lib_file" ]] && source "$lib_file"
done

# Workspace directory
WORKSPACE_DIR=".qlab"

# Load config if workspace is initialized
_load_workspace_config() {
    local conf="$WORKSPACE_DIR/qlab.conf"
    if [[ -f "$conf" ]]; then
        load_config "$conf"
        ensure_ssh_key
    fi
}

# --- Commands ---

cmd_init() {
    info "Initializing QLab workspace..."
    echo ""
    echo "  QLab creates a local .qlab/ directory to store disks, VM state,"
    echo "  plugins, images, and cached data. This is your lab workspace."
    echo ""

    local dirs=("disks" "state" "plugins" "images" "cache" "logs")
    for dir in "${dirs[@]}"; do
        mkdir -p "$WORKSPACE_DIR/$dir"
        success "Created $WORKSPACE_DIR/$dir"
    done

    if [[ ! -f "$WORKSPACE_DIR/qlab.conf" ]]; then
        cp "$QLAB_ROOT/etc/qlab.conf.example" "$WORKSPACE_DIR/qlab.conf"
        success "Created default config: $WORKSPACE_DIR/qlab.conf"
    else
        info "Config already exists: $WORKSPACE_DIR/qlab.conf"
    fi

    echo ""
    success "Workspace initialized in $WORKSPACE_DIR/"
    ensure_ssh_key
    echo "  Next steps:"
    echo "    qlab install hello-lab   # install your first lab plugin"
    echo "    qlab run hello-lab       # run the lab"
}

cmd_status() {
    if [[ ! -d "$WORKSPACE_DIR" ]]; then
        warn "No workspace found. Run 'qlab init' first."
        return 1
    fi

    _load_workspace_config

    echo "${BOLD}QLab Workspace Status${RESET}"
    echo "  Workspace path:  $(cd "$WORKSPACE_DIR" && pwd)"
    echo "  Config:          $WORKSPACE_DIR/qlab.conf"
    echo ""

    # Installed plugins
    echo "${BOLD}Installed Plugins:${RESET}"
    local plugin_count=0
    if [[ -d "$WORKSPACE_DIR/plugins" ]]; then
        for pdir in "$WORKSPACE_DIR/plugins"/*/; do
            [[ -d "$pdir" ]] || continue
            local pname
            pname="$(basename "$pdir")"
            local pdesc="(no description)"
            if [[ -f "$pdir/plugin.conf" ]]; then
                pdesc=$(jq -r '.description // "(no description)"' "$pdir/plugin.conf" 2>/dev/null || echo "(no description)")
            fi
            echo "  - $pname: $pdesc"
            plugin_count=$((plugin_count + 1))
        done
    fi
    if [[ $plugin_count -eq 0 ]]; then
        echo "  (none)"
    fi
    echo ""

    # VM state
    echo "${BOLD}Running VMs:${RESET}"
    list_running_vms
}

cmd_reset() {
    if [[ ! -d "$WORKSPACE_DIR" ]]; then
        warn "No workspace found. Nothing to reset."
        return 0
    fi

    # Per-plugin reset
    if [[ $# -gt 0 ]]; then
        _load_workspace_config

        local pname="$1"
        validate_plugin_name "$pname" || return 1

        # Check plugin is installed
        if [[ ! -d "$PLUGIN_DIR/$pname" ]]; then
            error "Plugin '$pname' is not installed."
            return 1
        fi

        # Stop VM(s): exact match
        if is_vm_running "$pname"; then
            stop_vm "$pname"
        fi
        # Stop sub-VMs: prefix match (<pname>-*)
        for pid_file in "$STATE_DIR/${pname}-"*.pid; do
            [[ -f "$pid_file" ]] || continue
            local vm_name
            vm_name=$(basename "$pid_file" .pid)
            stop_vm "$vm_name" 2>/dev/null || true
        done

        # Clean state files (prefix match covers multi-VM)
        rm -f "$STATE_DIR/${pname}".pid "$STATE_DIR/${pname}".port "$STATE_DIR/${pname}".ports
        rm -f "$STATE_DIR/${pname}-"*.pid "$STATE_DIR/${pname}-"*.port "$STATE_DIR/${pname}-"*.ports
        rm -f "$STATE_DIR/.allocated_ports"
        # shellcheck disable=SC2153  # LOG_DIR is defined in lib/vm.bash
        rm -f "$LOG_DIR/${pname}".log
        rm -f "$LOG_DIR/${pname}-"*.log

        # Delete lab artifacts (overlay disk, cidata, cloud-init files)
        if [[ -d "$PLUGIN_DIR/$pname/lab" ]]; then
            rm -rf "$PLUGIN_DIR/$pname/lab"
        fi

        success "Plugin '$pname' has been reset. Run 'qlab run $pname' to start fresh."
        return 0
    fi

    # Full workspace reset (no arguments)
    warn "This will delete all data in $WORKSPACE_DIR/ (disks, plugins, state)."
    if ! confirm_yesno "Are you sure you want to reset the workspace?"; then
        info "Reset cancelled."
        return 0
    fi

    # Stop all running VMs first
    if [[ -d "$WORKSPACE_DIR/state" ]]; then
        for pidfile in "$WORKSPACE_DIR/state"/*.pid; do
            [[ -f "$pidfile" ]] || continue
            local vm_name
            vm_name="$(basename "$pidfile" .pid)"
            stop_vm "$vm_name" 2>/dev/null || true
        done
    fi

    rm -rf "${WORKSPACE_DIR:?}/"*
    success "Workspace cleared."

    # Re-initialize
    cmd_init
}

cmd_install() {
    if [[ $# -eq 0 ]]; then
        error "Usage: qlab install <plugin-name|path|git-url>"
        return 1
    fi

    if [[ ! -d "$WORKSPACE_DIR" ]]; then
        warn "No workspace found. Run 'qlab init' first."
        return 1
    fi

    _load_workspace_config

    local target="$1"

    # Check if already installed (by name)
    local pname
    pname="$(basename "$target" .git)"
    pname="${pname#qlab-plugin-}"
    if [[ -d "$PLUGIN_DIR/$pname" ]]; then
        warn "Plugin '$pname' is already installed."
        return 0
    fi

    # If target is not a path or URL, try looking it up in the registry
    if [[ ! -d "$target" && "$target" != *.git && "$target" != https://* ]]; then
        # First try bundled plugins (handled by install_plugin)
        if [[ -d "$QLAB_ROOT/plugins/$target" ]]; then
            install_plugin "$target"
            return $?
        fi

        # Try registry lookup
        local git_url
        git_url=$(get_plugin_git_url "$target" 2>/dev/null || true)
        if [[ -n "$git_url" ]]; then
            local reg_version
            reg_version=$(get_plugin_version "$target" 2>/dev/null || true)
            info "Found '$target' in registry: $git_url (v${reg_version:-latest})"
            install_plugin "$git_url" "$reg_version"
            return $?
        fi
    fi

    install_plugin "$target"
}

cmd_uninstall() {
    if [[ $# -eq 0 ]]; then
        error "Usage: qlab uninstall <plugin-name>"
        return 1
    fi
    uninstall_plugin "$1"
}

cmd_run() {
    if [[ $# -eq 0 ]]; then
        error "Usage: qlab run <plugin-name>"
        return 1
    fi
    run_plugin "$1"
}

cmd_stop() {
    if [[ $# -eq 0 ]]; then
        error "Usage: qlab stop <plugin-name>"
        return 1
    fi

    local name="$1"

    # Exact match — single VM with this name
    if [[ -f "$STATE_DIR/${name}.pid" ]]; then
        stop_vm "$name"
        return $?
    fi

    # Prefix match — stop all VMs named <name>-*
    local matches=()
    for pidfile in "$STATE_DIR/${name}"-*.pid; do
        [[ -f "$pidfile" ]] || continue
        matches+=("$(basename "$pidfile" .pid)")
    done

    if [[ ${#matches[@]} -eq 0 ]]; then
        warn "No running VM found for '$name'."
        return 1
    fi

    info "Stopping ${#matches[@]} VM(s) matching '$name'..."
    if [[ ${#matches[@]} -ge 2 ]]; then
        # Parallel stop for 2+ VMs
        local pids=()
        for vm in "${matches[@]}"; do
            stop_vm "$vm" &
            pids+=($!)
        done
        local failed=0
        for pid in "${pids[@]}"; do
            wait "$pid" || failed=$((failed + 1))
        done
    else
        local failed=0
        for vm in "${matches[@]}"; do
            stop_vm "$vm" || failed=$((failed + 1))
        done
    fi

    if [[ $failed -gt 0 ]]; then
        warn "$failed VM(s) failed to stop."
        return 1
    fi
    return 0
}

cmd_shell() {
    local no_wait=""
    local command=""
    local args=()

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --no-wait) no_wait="--no-wait"; shift ;;
            -c)        command="$2"; shift 2 ;;
            *)         args+=("$1"); shift ;;
        esac
    done

    if [[ ${#args[@]} -eq 0 ]]; then
        error "Usage: qlab shell [--no-wait] [-c <command>] <vm-name> [ssh-user]"
        return 1
    fi

    shell_vm "${args[0]}" "${args[1]:-labuser}" "$no_wait" "$command"
}

cmd_log() {
    if [[ $# -eq 0 ]]; then
        error "Usage: qlab log <plugin-name>"
        return 1
    fi

    local name="$1"
    local log_dir="$WORKSPACE_DIR/logs"

    # Exact match
    if [[ -f "$log_dir/${name}.log" ]]; then
        info "Showing log: $log_dir/${name}.log (Ctrl+C to stop)"
        tail -f "$log_dir/${name}.log"
        return 0
    fi

    # Prefix match — find all logs named <name>-*.log
    local matches=()
    for logfile in "$log_dir/${name}"-*.log; do
        [[ -f "$logfile" ]] || continue
        matches+=("$logfile")
    done

    if [[ ${#matches[@]} -eq 0 ]]; then
        warn "No log found for '$name'."
        return 1
    fi

    if [[ ${#matches[@]} -eq 1 ]]; then
        info "Showing log: ${matches[0]} (Ctrl+C to stop)"
        tail -f "${matches[0]}"
        return 0
    fi

    # Multiple matches — list them for the user
    info "Multiple VM logs found for '$name':"
    for logfile in "${matches[@]}"; do
        echo "  qlab log $(basename "$logfile" .log)"
    done
    return 0
}

cmd_ports() {
    if [[ ! -d "$WORKSPACE_DIR" ]]; then
        warn "No workspace found. Run 'qlab init' first."
        return 1
    fi

    _load_workspace_config

    echo "${BOLD}Port Map${RESET}"
    echo ""

    # Collect active ports from .ports files in state dir
    local has_ports=0
    if [[ -d "$STATE_DIR" ]]; then
        local entries=()
        for ports_file in "$STATE_DIR"/*.ports; do
            [[ -f "$ports_file" ]] || continue
            local vm_name
            vm_name="$(basename "$ports_file" .ports)"
            # Check if VM is actually running
            if ! is_vm_running "$vm_name"; then
                continue
            fi
            while IFS=: read -r proto host_port guest_port; do
                [[ -n "$proto" ]] || continue
                entries+=("${host_port}:${vm_name}:${proto}:${guest_port}")
                has_ports=1
            done < "$ports_file"
        done

        if [[ $has_ports -eq 1 ]]; then
            # Sort by host port number
            IFS=$'\n' read -r -d '' -a sorted_entries < <(printf '%s\n' "${entries[@]}" | sort -t: -k1 -n && printf '\0') || true

            echo "${BOLD}Active port forwards (running VMs):${RESET}"
            printf "  %-8s %-30s %-6s %s\n" "HOST" "VM" "PROTO" "GUEST"
            printf "  %-8s %-30s %-6s %s\n" "--------" "------------------------------" "------" "-----"
            for entry in "${sorted_entries[@]}"; do
                IFS=: read -r host_port vm_name proto guest_port <<< "$entry"
                printf "  %-8s %-30s %-6s %s\n" "$host_port" "$vm_name" "$proto" "$guest_port"
            done
            echo ""
        fi
    fi

    if [[ $has_ports -eq 0 ]]; then
        echo "  No active port forwards."
        echo ""
        echo "  Ports are allocated dynamically when VMs start."
        echo "  Run a plugin first: qlab run hello-lab"
        echo ""
    fi

    # Running VMs summary
    echo "${BOLD}Running VMs:${RESET}"
    list_running_vms
}

cmd_test() {
    if [[ $# -eq 0 ]]; then
        error "Usage: qlab test <plugin-name>"
        return 1
    fi
    test_plugin "$1"
}

cmd_list() {
    local sub="${1:-installed}"
    case "$sub" in
        installed)
            echo "${BOLD}Installed Plugins:${RESET}"
            list_installed_plugins
            ;;
        available)
            _load_workspace_config
            echo "${BOLD}Available Plugins (from registry):${RESET}"
            list_available_plugins
            ;;
        *)
            error "Unknown list sub-command '$sub'. Use: installed, available"
            return 1
            ;;
    esac
}

# --- Usage ---

usage() {
    cat <<EOF
QLab v0.3.0 - Modular CLI for QEMU/KVM educational labs

Usage:
  qlab <command> [options]

Commands:
  init          Initialize a new workspace
  status        Show workspace status
  reset [name]  Reset workspace, or a single plugin
  install       Install a plugin
  uninstall     Uninstall a plugin
  run           Run a plugin
  shell         Open SSH shell or run a command (-c) on a running VM
  stop          Stop a running VM
  log           Show VM boot log (tail -f)
  test          Run automated tests for a plugin
  list          List plugins
  ports         Show SSH port map and conflicts

Options:
  -h, --help    Show this help message

Examples:
  qlab init
  qlab install hello-lab
  qlab run hello-lab
  qlab shell hello-lab              # waits for cloud-init
  qlab shell --no-wait hello-lab   # connects immediately
  qlab shell hello-lab -c "uname -a"  # run a command on the VM
  qlab stop hello-lab
  qlab log hello-lab
  qlab test pam-lab
  qlab reset hello-lab
  qlab list installed
  qlab list available
EOF
}

# --- Main argument parser ---

main() {
    if [[ $# -eq 0 ]]; then
        usage
        exit 0
    fi

    case "$1" in
        init)       shift; cmd_init "$@" ;;
        status)     shift; cmd_status "$@" ;;
        reset)      shift; cmd_reset "$@" ;;
        install)    shift; cmd_install "$@" ;;
        uninstall)  shift; cmd_uninstall "$@" ;;
        run)        shift; cmd_run "$@" ;;
        shell)      shift; cmd_shell "$@" ;;
        stop)       shift; cmd_stop "$@" ;;
        log)        shift; cmd_log "$@" ;;
        test)       shift; cmd_test "$@" ;;
        list)       shift; cmd_list "$@" ;;
        ports)      shift; cmd_ports "$@" ;;
        -h|--help)  usage ;;
        *)
            echo "Error: unknown command '$1'"
            echo ""
            usage
            exit 1
            ;;
    esac
}

main "$@"
